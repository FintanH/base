Hi. ðŸ˜€ We welcome you to contribute to the Unison base libraries. Here's how that works:

* Fork this repo on GitHub. Say to: `myuser/myunisonbase`.
* From UCM: 
  * `.> pull https://github.com/unisonweb/base .origin.base`
  * `.> fork origin.base me.base`
  * `.me.base> <hack hack hack>`
    * If while hacking you decide you want to sync with origin, just do:
      * `.origin.base> pull https://github.com/unisonweb/base`
      * `.me.base> merge origin.base` to sync
      * Alternately, you can do a `.me.base> pull https://github.com/unisonweb/base` directly
  * `.me.base> push git@github.com:myuser/myunisonbase` after you're done hacking and are ready to open the pull request.
  * `.me.base> pull-request.create https://github.com/unisonweb/base https://github.com/myuser/myunisonbase` and this will create some output. Copy that output to your clipboard. We don't literally use the GitHub pull request mechanism for Unison repositories, we use GitHub issues instead.
* Next, create an issue in this repo (that's right, an issue, __not__ a GitHub PR). Make the issue title something descriptive, and for the issue body, paste in the output generated by `pull-request.create` as well as some text describing the change, just like you would for any other pull request.
  * For long writeups, you may want to consider using [a Unison `Doc`](https://www.unisonweb.org/docs/documentation) stored in the repo to describe the changes. If you'd like do that, you can put that writeup in `.prs.y2020_m03_d10_myuser`, that is:
    * `y2020_m03_d10` is the date you are opening the PR (year, month, day), which is also a valid identifier in Unison
    * `myuser` is your GitHub username
    * Mention that you've done this in the GitHub issue so the reviewers know where to look.
* Use the GitHub issue comments for coordinating the review. Once merged, the maintainer will close the issue.

## Assigning authorship and license info

Unlike other languages, libraries in Unison are just loose collections of definitions, and the same definitions can appear in multiple libraries. Libraries are more like a playlist... the songs just exist, and you can assemble the same songs into multiple playlists (the type `Optional` can be named 6 different things and referenced in 40 different libraries, and it has the same identity everywhere). Other users of the library may slice, dice, rename, and remix the definitions. To support this worthy goal, we assign author / copyright holder and license information to each individual definition.

When you open your first PR, we'll create an author and license value for you, and you can link that to your new definitions in bulk. We will walk you through that once you open the PR. This process is pretty simple but is not as streamlined as we'd like yet.

## Conventions used in this repository

For a definition (we'll use `List.map` as an example), here's where to put the documentation, tests, and examples:

* `List.map.doc` is the primary documentation. It should be linked to `List.map` using the `link` command [as described here](https://www.unisonweb.org/docs/documentation). This ensures that the user can view these docs using `docs List.map`.
  * `List.map.docs.whyListIsTheBest`, `List.map.docs.basicListProcessing` are any supporting documentation.
  * Suggestion: within the primary documentation, you can link to other documentation!
* `List.map.examples.ex1` or `List.map.examples.moreDescriptiveName` are examples (which might be used by the documentation).
* `List.map.tests.ex1`, `List.map.tests.someBetterName` are named tests for `List.map`.

We put the docs, examples, and tests right next to the corresponding definitions for a couple of reasons:

* It plays well with [suffix-based name resolution](https://www.unisonweb.org/docs/language-reference/#suffix-based-name-resolution) since the tests, examples, and docs don't share a suffix with the original definition.
* It's a bit easier to do slicing and dicing of libraries when the definitions and their tests and examples are all together under a single namespace.

## Contributions that are most welcome

This isn't a complete list, but here are some ideas for contributions you can make:

* Documentation and/or tests or examples for existing definitions
* New definitions... like maybe add your favorite missing function on `List`
* Add a new data structure!
* Add some interesting functions that work with abilities. For instance, see the `Stream` namespace.

## Making changes to `base` later is not a big deal

Unlike other languages, where changing the standard library involves everyone downstream enduring a tedious upgrade cycle, definitions in Unison never change and are always valid once they are created. If we change the naming conventions or shuffle definitions around later, that's no big deal and doesn't break anyone's code. It's also not a problem for definitions to start out here in base and perhaps later get broken out into separate libraries--none of the downstream code which obtained the definitions from here originally will break.

We hope this also means there's less need for [bikeshedding about small details](https://en.wikipedia.org/wiki/Law_of_triviality), because changing small things like naming and organization later is easy.
